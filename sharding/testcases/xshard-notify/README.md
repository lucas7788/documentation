# Cross Shard Notification

Cross Shard Notification is to support smart contract in shard to invoke smart contract in another shard asynchronously.

Because it is asynchronous, transaction in another shard will be another transaction, and smart contract A which triggered the notification will not be able to get its result.

Cross-Shard notification is based on verifiable cross-shard message queue.
If two cross-shard notification created by one block, and they have same target shard, target shard will process the two notifications in same order with source shard.

The notified shard execute notification pushed by original transaction, and the notification can be queried by using original transaction hash. Using ontology-cli and the command ```TODO``` can do it.

## Test cases

* root -> shard notification
* shard -> root notification
* shard -> shard notification
* relay of cross-shard notification message
* validation of cross-shard message queue
* no cross-shard notification if its source transaction failed or aborted

### Case 1, root notify shard

Using x-shard transfer ONG as test method. The method ```XShardTransferOng``` use NotifyRemoteShard Runtime API to notify shard receive ONG. You can see ONG decrease form root account and increase at shard account with same amount.

You can get account balance info by using ontology-cli, the command is ```./ontology asset balance [address|wallet account label]```

#### Test Procedure

1. Confirm account own enough ONG at root;
2. Invoke XShardTransferOng, wait transaction handled;
3. Wait shard handle notify;
4. Check account balance change at root and shard, check notify tx's state at shard.

#### Expectation

1. The decreased balance at root shard is transferred amount, and is also increased balance at shard;
2. The notify shard tx state is 1, and there are two event, one is transfer ONG from shard-asset system contract to account, the other is ```xshardReceive```, the event structure is followed:
```
type TransferEvent struct {
	AssetId AssetId
	From    common.Address
	To      common.Address
	Amount  *big.Int
}
type XShardReceiveEvent struct {
	*TransferEvent
	TransferId *big.Int
	FromShard  common.ShardID
}
```
there is a event example, in this case, FromShard should be 0:
```
    {
       "xshardReceive",
       "1",
       "AFmseVrdL9f9oyCzZefL9tG6UbviRj6Fv6",
       "AFmseVrdL9f9oyCzZefL9tG6UbviRj6Fv6",
       "10000000",
       "10",
       "0"
   }
```

### Case 2, shard notify root

There are most similar with Case 1, only need to forward sender and receiver.

### Case 3, shard notify shard

```XShardTransferOng``` cannot transfer ONG from one shard to sibling shard. So we need to deploy neovm contract to verify this case.

The test contract reference to [OEP-11 demo](https://github.com/qiluge/ontology-xshard-contract/tree/master/xshardcall), the caller contract could Notify callee contract, then the callee's notify count will increase 1.

#### Test Procedure

1. Invoke caller contract method ```xshardNotify``` at shard 1;
2. Wait invoke and remote shard notify handled;
3. Invoke callee contract method ```getXShardCount```  at shard 2 to query notify count and check it increment num;
4. Query remote notify tx states.

#### Expectation

1. Notify count increase 1;
2. The states is 1 and notification is normal.

### Case 4, relay of cross-shard notification message

Cross-shard msg passed by p2p network to destination shard. And if destination shard isn't connecting to self shard straightly, the msg would be relayed by connected shard to destination shard.

In this case, tester should insure that two shard should not connected.

#### Test Procedure

1. Insure shard A and shard B connected, shard B and shard C connected, but shard A and shard C not connected;
2. Invoke contract method that notify shard C at shard A;
3. Wait source transaction and shardTx at shard C handled;
4. Query shardTx states at shard C;

#### Expectation

1. ShardTx states is success.

### Case 5, validation of cross-shard message queue

Message Queue consists of two parts, message-root chain and message signature. One message should contain self hash and hash of last msg generated by last block that contains cross-shard msg, the last msg
hash called prevMsgHash. And the msg hash signature signed by shard current consensus node should also be contained. If shard received msg. it fetch sender shard consensus node public key from self ledger, and use these public keys to
verify msg. And then, compare the prevMsgHash with the last received msg hash, if they are inconsistent, drop the msg.

#### Test Procedure

1. Construct first msg, its' prevMsgHash is zero, representing it is first msg;
2. Use consensus node to sign it, and fit 5 signature to msg at last;
3. Send it to destination shard;
4. Construct second msg, its' prevMsgHash is first msg hash, but it only contains 4 signature;
5. Send it to destination shard;
6. Construct third msg, its' prevMsgHash is first msg hash, it contains 5 signature;
7. Send it to destination shard;
8. Construct forth msg, its' prevMsgHash is first msg hash, it contains 5 signature;
9. Send it to destination shard;
10. Construct fifth msg, its' prevMsgHash is third msg hash, it contains 5 signature;

#### Expectation

1. First, third, fifth msg verify passed;
2. Second, forth msg verify failed, second signature not enough, forth used duplicated prevMsgHash.

### Case 6, no cross-shard notification if its source transaction failed or aborted

```NotifyRemoteShard``` dependents on source transaction context, if source tx return err, the notify will not be generated.

So, tester may use these example code to test this case:
```
def xshardNotify(a, b):
    list = [a, b]
    argsByteArray = Serialize(list)
    targetShardId = 2
    res = NotifyRemoteShard(targetShardId, X_SHARD_INVOKED_CONTRACT, 30000, "notifyCallee", argsByteArray)
    assert (res)
    throw    // deliberately let the tx fail
    return True
```

#### Test Procedure

1. Invoke the test contract method;
2. Wait tx handled;
3. Query source tx at current shard and query shardTx at destination shard.

#### Exception

1. Source tx stats is failed;
2. ShardTx return nil, because the destination shard cannot receive this notification.